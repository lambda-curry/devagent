---
description: Standardize testing patterns using Vitest, @testing-library/react, and React Router v7
globs: apps/ralph-monitoring/**/*.test.ts, apps/ralph-monitoring/**/*.test.tsx
alwaysApply: true
---

## Core Testing Libraries & Setup

- **Vitest as the Test Runner**
  - Use Vitest for all tests (unit, integration, component)
  - Import from vitest: `import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';`
  - Use `vi.mock()` for mocking dependencies
  - Use `vi.fn()` for creating mock functions
  ```tsx
  // ✅ DO: Use vi.mock for module mocking
  vi.mock('@lambdacurry/forms', () => ({
    FormError: () => <div data-testid="form-error">Error message</div>
  }));
  
  // ✅ DO: Use vi.fn for function mocking
  const mockSubmit = vi.fn();
  ```

- **@testing-library/react for Component Testing**
  - Use `render`, `screen`, `fireEvent`, and `waitFor` from @testing-library/react
  - Use `userEvent` for simulating user interactions (preferred over `fireEvent`)
  - Use `screen` queries to find elements (prefer accessible queries)
  ```tsx
  // ✅ DO: Use screen queries with accessible selectors
  const submitButton = screen.getByRole('button', { name: /submit/i });
  const emailInput = screen.getByLabelText(/email/i);
  
  // ❌ DON'T: Use non-accessible selectors
  // const submitButton = screen.getByTestId('submit-btn');
  ```

## React Router v7 Testing

- **Prefer route objects with `createMemoryRouter`**
  - Use `createMemoryRouter` for integration tests; avoid legacy `<MemoryRouter><Routes>`
  - Example:
  ```tsx
  import { createMemoryRouter, RouterProvider } from 'react-router';
  const router = createMemoryRouter([{ path: '/', Component: Home }], { initialEntries: ['/'] });
  ```

- **Use provided helpers from `app/lib/test-utils/router.tsx`** (when created)
  - `renderWithRouter({ routes, initialEntries })` for integration flows
  - `createRoutesFor(Component, extras)` for single-route convenience
  - `createRoutesStub(routes)` for component-level tests
  ```tsx
  // ✅ DO: Use the router test utils (when available)
  const { router, container } = renderWithRouter({
    routes: [createRoutesFor(MyComponent)],
    initialEntries: ['/']
  });
  ```

- **Use `makeActionArgs` helper for route action/loader testing** (when created)
  - Centralizes boilerplate for calling actions/loaders in tests
  - Includes all required properties (`request`, `params`, `context`, `unstable_pattern`)
  - Ensures type safety and prevents TypeScript errors
  ```tsx
  // ✅ DO: Use makeActionArgs helper and test DataWithResponseInit directly
  import { makeActionArgs } from '~/lib/__tests__/test-utils';
  
  const req = new Request('http://x/api/endpoint', {
    method: 'POST',
    body: formData
  });
  
  // For routes that use return data() (no throw)
  const result = await action(makeActionArgs(req));
  expect(result.type).toBe('DataWithResponseInit');
  expect((result as { init?: ResponseInit }).init?.status).toBe(400);
  const payload = (result as { data: unknown }).data as Record<string, unknown>;
  
  // For routes that use throw data(), let it throw and capture it:
  const thrown = await action(makeActionArgs(req)).catch(error => error);
  expect(thrown).toMatchObject({ type: 'DataWithResponseInit', init: { status: 400 } });
  
  // ❌ DON'T: Manually construct args with missing properties
  const result = await action({ request: req } as any); // Missing unstable_pattern
  const result = await action({ request: req, params: {}, context: {} }); // TypeScript error
  
  // ❌ DON'T: Use toResponse utility - test DataWithResponseInit directly
  // const response = toResponse(result); // Deprecated pattern
  ```

- **Avoid mocking router hooks**
  - ❌ DON'T mock `useNavigate`, `useParams`, `useLoaderData`, `useFetcher` in component tests
  - ✅ DO assert behavior via DOM and `router.state`

- **Redirect testing**
  - Trigger submit/navigation, then assert `router.state.location.pathname` and new UI
  ```tsx
  await userEvent.click(screen.getByRole('button', { name: /submit/i }));
  expect(router.state.location.pathname).toBe('/success');
  expect(await screen.findByText('Success!')).toBeInTheDocument();
  ```

## Form Testing with React Router

- **Testing Form Submissions**
  - Create routes with action handlers for form submission tests
  - Use `<Form method="post">` in components and test actual form submission
  ```tsx
  // ✅ DO: Test form submissions with actions
  const routes = [
    {
      path: '/login',
      Component: LoginForm,
      action: async ({ request }) => {
        const formData = await request.formData();
        // Process form data
        return redirect('/dashboard');
      }
    },
    { path: '/dashboard', Component: Dashboard }
  ];
  
  // In test:
  await userEvent.type(screen.getByLabelText(/email/i), 'test@example.com');
  await userEvent.type(screen.getByLabelText(/password/i), 'password123');
  await userEvent.click(screen.getByRole('button', { name: /login/i }));
  expect(router.state.location.pathname).toBe('/dashboard');
  ```

- **Testing Form Validation**
  - Test both client-side and server-side validation
  - For client validation, submit invalid data and check for error messages
  - For server validation, mock action to return validation errors
  ```tsx
  // Client validation test
  await userEvent.type(screen.getByLabelText(/email/i), 'invalid-email');
  await userEvent.click(screen.getByRole('button', { name: /submit/i }));
  expect(screen.getByText(/invalid email address/i)).toBeInTheDocument();
  
  // Server validation test
  const routes = [
    {
      path: '/login',
      Component: LoginForm,
      action: async () => {
        return { errors: { _form: { message: 'Invalid credentials' } } };
      }
    }
  ];
  ```

## Testing with remix-hook-form and @lambdacurry/forms

- **Forms with `remix-hook-form` + `@lambdacurry/forms`**
  - Place `<FormError name="_form" />` before submit buttons
  - Server error shape: `{ errors: { _form: { message } } }`
  - Test form components with proper context providers
  ```tsx
  // ✅ DO: Test form components with proper providers
  const TestComponent = () => (
    <RemixFormProvider {...methods}>
      <fetcher.Form onSubmit={methods.handleSubmit}>
        <TextField name="email" label="Email" />
        <FormError />
        <button type="submit">Submit</button>
      </fetcher.Form>
    </RemixFormProvider>
  );
  
  // In test:
  const fetcher = { Form: ({ children }) => <form>{children}</form>, state: 'idle' };
  const methods = useRemixForm({
    resolver: zodResolver(schema),
    defaultValues: { email: '' },
    fetcher
  });
  ```

- **Testing Form Error Display**
  - Test that form errors are displayed correctly
  - Test both field-level and form-level errors
  ```tsx
  // Field-level error test
  await userEvent.type(screen.getByLabelText(/email/i), 'invalid');
  await userEvent.click(screen.getByRole('button', { name: /submit/i }));
  expect(screen.getByText(/invalid email/i)).toBeInTheDocument();
  
  // Form-level error test
  const { errors } = { errors: { _form: { message: 'Server error' } } };
  render(<FormError errors={errors} />);
  expect(screen.getByText(/server error/i)).toBeInTheDocument();
  ```

## Testing useFetcher

- **`useFetcher` testing with `createRoutesStub`**
  - Define a target route with `action`; trigger `fetcher.submit` and assert rendered data
  - Use `createRoutesStub` instead of mocking router hooks so components receive full data-router context
  - **CRITICAL**: Parse request as `text()` → `URLSearchParams` (not `formData()` directly)
    - `fetcher.submit({ object })` sends `application/x-www-form-urlencoded`
    - jsdom doesn't set Content-Type headers properly
    - Direct `request.formData()` throws: `Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded"`
  
  ```tsx
  // ✅ DO: Parse as text first, then URLSearchParams
  const actionSpy = vi.fn().mockResolvedValue(null);
  const routes = [
    {
      path: '/',
      Component: () => <DatasetDropdown datasets={datasets} activeDatasetId="dataset-1" />
    },
    {
      path: '/api/dataset/switch',
      action: async ({ request }) => {
        const bodyText = await request.text();
        const params = new URLSearchParams(bodyText);
        
        // If you need FormData, convert it:
        const formData = new FormData();
        params.forEach((value, key) => formData.append(key, value));
        
        return actionSpy({ request, formData });
      }
    }
  ];
  const Stub = createRoutesStub(routes);
  render(<Stub initialEntries={['/']} />);

  await userEvent.click(screen.getByRole('button', { name: /marketing overview/i }));
  await userEvent.click(await screen.findByRole('option', { name: /finance snapshot/i }));

  await waitFor(() => expect(actionSpy).toHaveBeenCalled());
  
  // ❌ DON'T: Call formData() directly - throws error in tests
  action: async ({ request }) => {
    const formData = await request.formData(); // Throws in jsdom!
    return actionSpy({ formData });
  }
  ```

- **See:** [fetcher-testing-patterns.md](mdc:docs/testing/fetcher-testing-patterns.md) for comprehensive guide and examples (if documentation exists)

## Async & DOM Events

- **Async & DOM events**
  - Use realistic user interactions; fallback to `dispatchEvent` for jsdom gaps
  - File input: set `input.files` via `Object.defineProperty` then dispatch `change`
  - DnD: inject `dataTransfer.files` on a `DragEvent`
  ```tsx
  // File input testing
  const file = new File(['file content'], 'test.txt', { type: 'text/plain' });
  const input = screen.getByLabelText(/upload file/i);
  Object.defineProperty(input, 'files', { value: [file] });
  fireEvent.change(input);
  ```

## Test Organization & Best Practices

- **Test File Organization**
  - Name test files with `.test.tsx` extension
  - Use descriptive suffixes for test types: `.unit.test.tsx`, `.integration.test.tsx`, `.ui.test.tsx`
  - Co-locate tests with implementation when possible
  ```text
  ├── components/
  │   ├── Button.tsx
  │   └── Button.test.tsx
  ├── lib/
  │   ├── utils.ts
  │   └── __tests__/
  │       ├── utils.unit.test.ts
  │       └── form.integration.test.tsx
  ```

- **Test Structure**
  - Use descriptive test names that explain the behavior being tested
  - Group related tests with `describe` blocks
  - Use `beforeEach` for common setup
  ```tsx
  describe('LoginForm', () => {
    beforeEach(() => {
      // Common setup
    });
    
    it('submits form with valid data and redirects to dashboard', async () => {
      // Test implementation
    });
    
    it('displays validation errors for invalid email', async () => {
      // Test implementation
    });
  });
  ```

- **Mocking Best Practices**
  - Mock external dependencies, not internal implementation
  - Reset mocks between tests with `vi.resetAllMocks()`
  - Use `vi.spyOn` for partial mocking
  - **Type route actions properly** using `RouteObject['action']` instead of `any`
  ```tsx
  // ✅ DO: Type action mocks with RouteObject
  import type { RouteObject } from 'react-router';
  
  const renderComponent = (
    actionMocks: {
      renameAction?: RouteObject['action'];
      submitAction?: RouteObject['action'];
    } = {}
  ) => {
    const routes = [
      { path: '/', Component: MyComponent },
      { path: '/api/rename', action: actionMocks.renameAction || (async () => null) }
    ];
    const Stub = createRoutesStub(routes);
    return render(<Stub initialEntries={['/']} />);
  };
  
  // ❌ DON'T: Use 'any' for action types
  const renderComponent = (actionMocks: { renameAction?: any } = {}) => { /* ... */ }
  
  // ✅ DO: Mock external dependencies
  vi.mock('~/lib/api', () => ({
    fetchData: vi.fn().mockResolvedValue({ data: 'mocked data' })
  }));
  
  // ✅ DO: Use spyOn for partial mocking
  const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
  expect(consoleSpy).toHaveBeenCalled();
  consoleSpy.mockRestore();
  ```

## jsdom Limitations for Complex Components

- **Complex components may not be testable in jsdom**
  - Components with intricate `useEffect` orchestration (AbortController, async operations, timers)
  - Multiple `useFetcher` hooks with complex state management
  - Browser API dependencies (localStorage, window.matchMedia)
  
  ```tsx
  // ❌ DON'T: Try to test overly complex components in jsdom
  describe('ComplexUploadComponent', () => {
    it('handles upload with progress tracking', async () => {
      // This will hang if component has:
      // - useEffect monitoring useFetcher state
      // - AbortController coordination
      // - setTimeout for navigation
      // - Progress callbacks
      render(<ComplexUploadComponent />);
    });
  });
  
  // ✅ DO: Test at API/route level instead
  describe('upload route action', () => {
    it('creates dataset in database', async () => {
      const result = await uploadAction({ request, params: {}, context: {} });
      expect(getStatus(result)).toBe(202);
      
      const datasets = await testDb.select().from(userDatabases);
      expect(datasets.length).toBe(1);
    });
  });
  
  // ✅ DO: Mock complex components when used as dependencies
  vi.mock('~/components/ComplexUpload', () => ({
    ComplexUpload: () => <div data-testid="upload-mock">Upload</div>
  }));
  ```

- **`createRoutesStub` does not support loaders**
  - Adding `loader` to root route causes silent rendering failures (empty HTML)
  - Pass data via component props or context providers instead
  - Our `createRoutesStub` helper handles this correctly (no loader, uses `AuthProvider.sessionOverride`)

- **Decision matrix for complex components:**
  - Simple presentational → Component test with `createRoutesStub`
  - With useFetcher, simple logic → Component test with route stub
  - **Complex useEffect orchestration → Route/API tests + mock component**
  - Multiple async operations → Integration tests with real DB

- **See detailed findings:** [jsdom-limitations-and-workarounds.md](mdc:docs/testing/jsdom-limitations-and-workarounds.md) (if documentation exists)

## Database Integration Testing

### When to Write Database-Level Tests
- Schema changes (FK constraints, NOT NULL, cascades)
- Multi-tenancy & data isolation (JOIN security)
- Database constraints (unique indexes, CHECK constraints)
- Migration verification

### Pattern: Test Database Setup
```tsx
import { createTestDatabase } from '~/lib/test-utils/testDatabase';
import type { Database } from '~/lib/db.server';

// Mutable reference for test database
let currentTestDb: Database | null = null;

// Mock db.server to use test database
vi.mock('~/lib/db.server', () => ({
  get db() {
    if (!currentTestDb) throw new Error('Test database not initialized');
    return currentTestDb;
  }
}));

// Mock external dependencies (not DB access)
vi.mock('~/lib/turso.server', () => ({
  issueFullAccessToken: vi.fn(async () => ({ token: 'mock', expiresAt: new Date().toISOString() })),
  getOrgDatabaseName: (orgId: string) => `rep-org-${orgId}`
}));

describe('Database Tests', () => {
  let testDb: Database;
  let cleanup: (() => Promise<void>) | undefined;

  beforeEach(async () => {
    const db = await createTestDatabase();
    testDb = db.db;
    currentTestDb = db.db; // Set for mock
    cleanup = db.cleanup;
  });

  afterEach(async () => {
    if (cleanup) await cleanup();
  });
});
```

### Testing FK Cascades & Constraints
```tsx
// Test ON DELETE SET NULL
it('sets FK to NULL when referenced row deleted', async () => {
  await testDb.insert(users).values({ id: 'user-1', /* ... */ });
  const [dataset] = await testDb.insert(orgDatasets).values({ /* ... */ }).returning();
  await testDb.update(users).set({ activeDatasetId: dataset.id }).where(eq(users.id, 'user-1'));
  
  await testDb.delete(orgDatasets).where(eq(orgDatasets.id, dataset.id));
  
  const user = await testDb.select().from(users).where(eq(users.id, 'user-1')).limit(1);
  expect(user[0]?.activeDatasetId).toBeNull();
});

// Test NOT NULL constraint
it('enforces NOT NULL constraint', async () => {
  await testDb.insert(users).values({ id: 'user-1', /* ... */ });
  
  const insertPromise = testDb.insert(orgDatasets).values({
    userId: 'user-1',
    organizationId: null as any, // Should fail
    /* ... */
  });
  
  await expect(insertPromise).rejects.toThrow();
});
```

### Testing Multi-Tenancy with JOINs
```tsx
it('JOIN only returns datasets from user organizations', async () => {
  // Create users in different orgs
  await testDb.insert(users).values([{ id: 'user-1' }, { id: 'user-2' }]);
  await testDb.insert(organizations).values([{ id: 'org-1' }, { id: 'org-2' }]);
  await testDb.insert(members).values({ userId: 'user-1', organizationId: 'org-1' });
  await testDb.insert(orgDatasets).values([
    { id: 'ds-1', organizationId: 'org-1', userId: 'user-1' },
    { id: 'ds-2', organizationId: 'org-2', userId: 'user-2' }
  ]);

  const results = await testDb
    .select()
    .from(orgDatasets)
    .innerJoin(members, eq(orgDatasets.organizationId, members.organizationId))
    .where(eq(members.userId, 'user-1'));

  expect(results).toHaveLength(1);
  expect(results[0].orgDatasets.id).toBe('ds-1');
});
```

### Best Practices
✅ **DO:**
- Test at DB level for schema validation
- Use `createTestDatabase()` for isolation (when available)
- Mock external APIs, not DB access
- Create fresh DB per test in `beforeEach`
- Use descriptive test data IDs

❌ **DON'T:**
- Mock Drizzle ORM methods (if using Drizzle)
- Reuse DB instances across tests
- Skip cleanup in `afterEach`
- Assume constraints work without testing

### Decision Tree
```text
Schema/constraints/relationships? → Database integration test (testDb)
Business logic? → Application/route test
UI behavior? → Component test (createRoutesStub)
```

## References
- Helpers: [router.tsx](mdc:apps/ralph-monitoring/app/lib/test-utils/router.tsx) (when created)
- Vitest Docs: [https://vitest.dev/api/](https://vitest.dev/api/)
- Testing Library Docs: [https://testing-library.com/docs/react-testing-library/intro/](https://testing-library.com/docs/react-testing-library/intro/)
